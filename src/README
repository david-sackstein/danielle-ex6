ellis.ackstein
talia.dym



**** design, focus on non trivial decisions ****

The task required a large number of operations and support in many different cases.
To maintain order throughout the implementation, we used the principle of encapsulation:
we divided the departments into detailed packages. We will explain our design choices on several packages.

scope package:
    We used the principle of polymorphism:
    we created 2 abstract classes to support the behavior of the scopes (in the scope package).
    1. Scope abstract class: the super class of all the scopes: global, method, if, while.
    2. NonGlobalScope abstract class: extends Scope, the super class of the scopes: method, if, while.

method package:
    this package is an inner package of scope, because it deals with the method scope.
    Method is the class representing a method declared in the code.
    MethodSignature is the class representing the signature of a method.
    MethodCall is the class representing a call to a method in the code.
    each one of the classes contains also static methods, converting strings from code into the class type.
    these methods are used in SyntaxParser, but we decided to place them in the methods classes in order to
    keep division into focused subjects between the classes.

variableDeclaration package:
    this package supports with all cases using types, variables declaration, value assignments etc.
    We created an Enum for the types (Type).
    We created a class representing a variable: Variable, and a class representing a value: Value.
    The Variable class holds a stack of assigned values that are pushed when assigned in the scope
    and are popped when the scope ends.


**** description for each S-java test-file ****

test001.sjavac 1 method definition has white space inside the name of the method.
test002.sjavac 0 method definition with legal method name.
test003.sjavac 1 assignment of a String value to a boolean variable.
test004.sjavac 1 end of method with no }.
test005.sjavac 1 method declaration with out a return statement in the end.
test006.sjavac 0 assignment of a int value to a boolean variable.
test007.sjavac 1 variable declaration with no ; in the end.
test008.sjavac 1 variable declaration with illegal name.
test009.sjavac 0 variable declaration with llegal name.
test010.sjavac 1 comment with a space before the //.
test011.sjavac 0 legal comment.
test012.sjavac 0 legal calling method with args.
test013.sjavac 1 method declaration with 2 arguments sharing the same name.
test014.sjavac 1 variable declaration using 2 lines.
test015.sjavac 1 2 global variables with the same name.
test016.sjavac 0 multiply variable of the same type declared in the same line.
test017.sjavac 0 calling method before and after the method declaration.
test018.sjavac 1 final modifier after type.
test019.sjavac 1 use of the static modifier in variable declaration.
test020.sjavac 1 initialized with  value after declaration time.

**** 6.1 - exceptions ****

To determine final return values (0/1/2) we used exception throwing.
We implemented the program so that in case of illegal code, the program throws an Exception. We turned
the exceptions informative using messages from the ExceptionMessages class.
If an exception was raised during the process,
we made sure to forward the exception to the final function that determines the return values,
and thus the return value is determined according to the exception.
2 will be returned if an IOException was thrown in the program.
1 will be return if an Exception (different from IOException) was thrown in the program.
0 will be returned if no exception was thrown.

**** 6.2 - object oriented design ****

add new types:
    1) add the types to the enum (variableDeclaration.Type).
    2) expand the implementation of Value, Tokenizer, SyntaxParser, Assignment, Declaration, Literals
    RegexDeclarations, RegexAssignment, RegexLiterals to support values of the new types.
    In particular, we will add conditions to the appropriate functions in order to support the
    special features of these type.
    Implementation which supports simple adding of new type like Factory, was not possible to use,
    because each type has different features, and the use of them is complicated and spread over many levels
    in the code.

Different methods return types:


Using methods of standard java:


**** 6.3 - regular expressions****
